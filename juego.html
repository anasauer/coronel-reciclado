<!DOCTYPE html>

<html lang="es">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Juego de Reciclado</title>

    <script src="https://cdn.tailwindcss.com"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">

    <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@400;700;900&display=swap" rel="stylesheet">

    <style>

        body {

            font-family: 'Raleway', sans-serif;

            background-image: url('img/ruinas.png');

            background-size: cover;

            background-position: center;

            background-attachment: fixed;

            color: #f9fafb;

            display: flex;

            align-items: center;

            justify-content: center;

            min-height: 100vh;

            text-align: center;

            padding: 20px;

        }

        .game-wrapper {

            background-color: rgba(17, 24, 39, 0.7);

            padding: 2rem;

            border-radius: 1.5rem;

            display: flex;

            flex-direction: column;

            align-items: center;

            width: 100%;

            max-width: 600px;

        }

        #gameCanvas {

            border-radius: 1rem;

            background-color: rgba(20, 25, 20, 0.8);

            border: 2px solid #4b5563;

            cursor: pointer;

            touch-action: none;

            width: 100%;

            height: auto;

            max-width: 450px;

            transition: all 0.3s ease;

        }

        .game-info {

            margin: 1rem 0;

            display: flex;

            flex-wrap: wrap;

            justify-content: center;

            align-items: center;

            gap: 1rem 2rem;

            font-weight: bold;

        }

        .flash-red {

            animation: incorrectPlacement 0.5s forwards;

        }

        @keyframes incorrectPlacement {

            0% { background-color: #ef4444; }

            100% { background-color: rgba(20, 25, 20, 0.8); }

        }

        .message-box {

            position: absolute;

            top: 50%;

            left: 50%;

            transform: translate(-50%, -50%);

            background-color: rgba(0, 0, 0, 0.8);

            border-radius: 1rem;

            padding: 2rem;

            border: 2px solid #3b82f6;

            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);

            display: none;

            z-index: 100;

        }

        .btn {

            background-color: #4b5563;

            color: white;

            padding: 0.75rem 1.5rem;

            border-radius: 9999px;

            font-weight: 600;

            transition-property: background-color, transform;

            transition-duration: 300ms;

            transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);

        }

        .btn:hover {

            background-color: #6b7280;

            transform: scale(1.05);

        }

    </style>

</head>

<body>

    <div class="game-wrapper">

        <h1 class="text-3xl font-bold mb-4">鮫勇 Juego de Reciclado</h1>

        <p class="mb-4">Arrastra y suelta los objetos en el contenedor correcto.</p>

        <div class="game-info">

            <div id="gameScore">Puntos: 0</div>

            <div id="gameLives">Vidas: 仇벒잺仇벒잺仇벒잺仇벒잺仇벒잺</div>

            <div id="gameTimer">Tiempo: 60</div>

            <button id="backGameButton" class="btn bg-gray-600 hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-slate-900">

                <i class="fas fa-arrow-left"></i>

                <span>Regresar</span>

            </button>

            <button id="restartGameButton" class="btn bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 focus:ring-offset-slate-900">

                <i class="fas fa-arrows-rotate"></i>

                <span>Reiniciar</span>

            </button>

            <button id="toggleButton" class="btn bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 focus:ring-offset-slate-900">

                <i id="toggleIcon" class="fas fa-pause"></i>

                <span id="toggleText">Pausar</span>

            </button>

        </div>

        <div class="relative w-full max-w-lg aspect-square">

            <canvas id="gameCanvas"></canvas>

            <div id="messageBox" class="message-box flex flex-col items-center justify-center text-center">

                <h2 id="messageTitle" class="text-xl font-bold text-gray-100 mb-2"></h2>

                <p id="messageText" class="text-gray-300 mb-4"></p>

                <button id="restartButton" class="btn btn-green">

                    Jugar de Nuevo

                </button>

                <button id="returnButton" class="btn bg-gray-600 hover:bg-gray-700 mt-4">

                    Regresar a la p치gina principal

                </button>

            </div>

        </div>

    </div>



   <script>
    class RecyclingGame {
      constructor(canvas, scoreEl, livesEl, timerEl, messageBoxEl, messageTitleEl, messageTextEl, restartButtonEl, toggleButtonEl, toggleIconEl, toggleTextEl, returnButtonEl, backGameButtonEl) {
        this.canvas = canvas;
        this.ctx = this.canvas.getContext('2d');
        this.scoreEl = scoreEl;
        this.livesEl = livesEl;
        this.timerEl = timerEl;
        this.messageBoxEl = messageBoxEl;
        this.messageTitleEl = messageTitleEl;
        this.messageTextEl = messageTextEl;
        this.restartButtonEl = restartButtonEl;
        this.toggleButtonEl = toggleButtonEl;
        this.toggleIconEl = toggleIconEl;
        this.toggleTextEl = toggleTextEl;
        this.returnButtonEl = returnButtonEl;
        this.backGameButtonEl = backGameButtonEl;

        this.items = [];
        this.bins = [];
        this.score = parseInt(localStorage.getItem('currentScore')) || 0;
        this.lives = 5;
        this.timer = 60;
        this.gameOver = false;
        this.isDragging = false;
        this.draggedItem = null;
        this.frameId = null;
        this.spawnTimer = 0;
        this.lastTime = 0;
        this.paused = false;

        this.itemTypes = [
          { type: 'glass', icon: '游', binSrc: 'img/vidrio.png', name: 'Vidrio' },
          { type: 'paper', icon: '游늯', binSrc: 'img/papel.png', name: 'Papel' },
          { type: 'plastic', icon: '游빖', binSrc: 'img/plastico.png', name: 'Pl치stico' },
          { type: 'metal', icon: '游볾', binSrc: 'img/metal.png', name: 'Metal' },
          { type: 'organic', icon: '游꼝', binSrc: 'img/organico.png', name: 'Org치nico' }
        ];

        this.correctSound = new Tone.Synth({
          oscillator: { type: 'sine' },
          envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.4 }
        }).toDestination();
        this.incorrectSound = new Tone.Synth({
          oscillator: { type: 'square' },
          envelope: { attack: 0.01, decay: 0.1, sustain: 0.01, release: 0.2 }
        }).toDestination();
       먝
        this.resizeCanvas = this.resizeCanvas.bind(this);
        this.gameLoop = this.gameLoop.bind(this);
       먝
        // Bind unified event handlers
        this.handleStart = this.handleStart.bind(this);
        this.handleMove = this.handleMove.bind(this);
        this.handleEnd = this.handleEnd.bind(this);

        this.restartButtonEl.addEventListener('click', () => this.restart());
        this.toggleButtonEl.addEventListener('click', () => this.togglePause());
        this.returnButtonEl.addEventListener('click', () => this.returnToHome());
        this.backGameButtonEl.addEventListener('click', () => this.returnToHome());
       먝
        this.addEventListeners();
      }

      addEventListeners() {
        // Remove old listeners to prevent duplication
        this.canvas.removeEventListener('mousedown', this.handleStart);
        this.canvas.removeEventListener('mousemove', this.handleMove);
        this.canvas.removeEventListener('mouseup', this.handleEnd);
        this.canvas.removeEventListener('touchstart', this.handleStart);
        this.canvas.removeEventListener('touchmove', this.handleMove);
        this.canvas.removeEventListener('touchend', this.handleEnd);

        // Add unified listeners
        this.canvas.addEventListener('mousedown', this.handleStart);
        this.canvas.addEventListener('mousemove', this.handleMove);
        this.canvas.addEventListener('mouseup', this.handleEnd);
        this.canvas.addEventListener('touchstart', this.handleStart);
        this.canvas.addEventListener('touchmove', this.handleMove);
        this.canvas.addEventListener('touchend', this.handleEnd);
      }

      getPointerPosition(e) {
        const rect = this.canvas.getBoundingClientRect();
        let clientX, clientY;

        // Handle both mouse and touch events
        if (e.touches && e.touches.length > 0) {
          clientX = e.touches[0].clientX;
          clientY = e.touches[0].clientY;
        } else if (e.changedTouches && e.changedTouches.length > 0) {
          clientX = e.changedTouches[0].clientX;
          clientY = e.changedTouches[0].clientY;
        } else {
          clientX = e.clientX;
          clientY = e.clientY;
        }
       먝
        // Corregimos la posici칩n relativa al tama침o real del canvas
        // Asegura que la posici칩n del mouse/dedo se mapee correctamente
        // al sistema de coordenadas interno del canvas.
        return {
          x: (clientX - rect.left) * (this.canvas.width / rect.width),
          y: (clientY - rect.top) * (this.canvas.height / rect.height)
        };
      }

      handleStart(e) {
        e.preventDefault();
        if (this.gameOver || this.paused) return;
        const pos = this.getPointerPosition(e);
        for (let i = this.items.length - 1; i >= 0; i--) {
          const item = this.items[i];
          // Se ha aumentado el 치rea de detecci칩n para facilitar el toque en m칩viles
          if (Math.abs(pos.x - item.x) < 30 && Math.abs(pos.y - item.y) < 30) {
            this.isDragging = true;
            this.draggedItem = item;
            // Mueve el item arrastrado al final del array para que se dibuje por encima de todo
            this.items = this.items.filter(i => i !== item);
            this.items.push(item);
            return;
          }
        }
      }

      handleMove(e) {
        e.preventDefault();
        if (!this.isDragging || !this.draggedItem) return;
        const pos = this.getPointerPosition(e);
        this.draggedItem.x = pos.x;
        this.draggedItem.y = pos.y;
      }

      handleEnd(e) {
        // e.preventDefault() NO se usa en touchend/mouseup a menos que quieras prevenir un click fantasma
        if (!this.draggedItem) return;
       먝
        // Get the final position for the drop
        const pos = this.getPointerPosition(e);
        this.draggedItem.x = pos.x;
        this.draggedItem.y = pos.y;
       먝
        let placedCorrectly = false;
        for (const bin of this.bins) {
          // Aumenta el 치rea de detecci칩n de la colisi칩n para m칩vil
          const xCollision = this.draggedItem.x > bin.x && this.draggedItem.x < bin.x + bin.width;
          const yCollision = this.draggedItem.y > bin.y && this.draggedItem.y < bin.y + bin.height;

          if (xCollision && yCollision) {
            if (this.draggedItem.type === bin.type) {
              this.score += 10;
              placedCorrectly = true;
              this.correctSound.triggerAttackRelease('C5', '8n');
            } else {
              this.lives -= 1;
              this.canvas.classList.add('flash-red');
              setTimeout(() => this.canvas.classList.remove('flash-red'), 500);
              this.incorrectSound.triggerAttackRelease('C3', '8n');
            }
            this.items = this.items.filter(item => item !== this.draggedItem);
            break;
          }
        }
        this.isDragging = false;
        this.draggedItem = null;
      }

      // [resto de las funciones sin cambios, como resizeCanvas, start, etc.]
      // Se han omitido aqu칤 por brevedad, pero en tu archivo final, las mantienes.
      resizeCanvas() {
        const container = this.canvas.parentElement;
        const size = Math.min(container.clientWidth, 450);
        this.canvas.width = size;
        this.canvas.height = size;
        this.initBins();
        this.draw();
      }

      start() {
        this.score = parseInt(localStorage.getItem('currentScore')) || 0;
        this.lives = 5;
        this.timer = 60;
        this.gameOver = false;
        this.items = [];
        this.spawnTimer = 0;
        this.lastTime = performance.now();
        this.paused = false;
       먝
        this.toggleIconEl.classList.remove('fa-play');
        this.toggleIconEl.classList.add('fa-pause');
        this.toggleTextEl.textContent = 'Pausar';
       먝
        this.scoreEl.textContent = `Puntos: ${this.score}`;
        this.livesEl.textContent = `Vidas: ${'仇벒잺'.repeat(this.lives)}`;
        this.timerEl.textContent = `Tiempo: ${this.timer}`;
        this.messageBoxEl.style.display = 'none';
       먝
        this.resizeCanvas();
       먝
        if (this.frameId) {
          cancelAnimationFrame(this.frameId);
        }
        this.gameLoop(this.lastTime);
      }

      restart() {
        // Reinicia el puntaje tanto en memoria como en localStorage
        localStorage.setItem('currentScore', '0');
        this.start();
      }

      // Guarda el puntaje en localStorage antes de regresar
      returnToHome() {
        if (this.frameId) {
          cancelAnimationFrame(this.frameId);
        }
        // Guarda el puntaje actual en localStorage
        localStorage.setItem('currentScore', this.score.toString());
        // Por razones de seguridad, es mejor no redirigir a URLs externas
        // window.location.href = "home.html";
        // En su lugar, podemos mostrar un mensaje
        this.messageTitleEl.textContent = "Volver치s pronto";
        this.messageTextEl.textContent = `Puntuaci칩n guardada: ${this.score}.`;
        this.messageBoxEl.style.display = 'flex';
        this.returnButtonEl.style.display = 'none';
      }

      togglePause() {
        this.paused = !this.paused;
        if (this.paused) {
          this.toggleIconEl.classList.remove('fa-pause');
          this.toggleIconEl.classList.add('fa-play');
          this.toggleTextEl.textContent = 'Reanudar';
        } else {
          this.toggleIconEl.classList.remove('fa-play');
          this.toggleIconEl.classList.add('fa-pause');
          this.toggleTextEl.textContent = 'Pausar';
          this.lastTime = performance.now();
          this.gameLoop(this.lastTime);
        }
      }

      initBins() {
        this.bins = [];
        const binWidth = this.canvas.width / this.itemTypes.length - 15;
        const binHeight = this.canvas.height / 5;
        const binY = this.canvas.height - binHeight - 20;

        this.itemTypes.forEach((type, index) => {
          const binImage = new Image();
          binImage.src = type.binSrc;
          binImage.onerror = () => { console.error(`Error loading image: ${type.binSrc}`); };
          this.bins.push({
            x: (index + 0.5) * (binWidth + 15) - binWidth / 2,
            y: binY,
            width: binWidth,
            height: binHeight,
            type: type.type,
            name: type.name,
            image: binImage
          });
        });
      }

      spawnItem() {
        const randomType = this.itemTypes[Math.floor(Math.random() * this.itemTypes.length)];
        const speed = 0.5 + this.score / 200;
        this.items.push({
          x: Math.random() * (this.canvas.width - 60) + 30,
          y: -30,
          icon: randomType.icon,
          type: randomType.type,
          speed: speed,
          isDragging: false
        });
      }

      draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
       먝
        this.bins.forEach(bin => {
          this.ctx.drawImage(bin.image, bin.x, bin.y, bin.width, bin.height);
          this.ctx.fillStyle = '#fff';
          this.ctx.font = 'bold 16px Raleway';
          this.ctx.textAlign = 'center';
          this.ctx.fillText(bin.name, bin.x + bin.width / 2, bin.y + bin.height + 20);
        });

        this.items.forEach(item => {
          this.ctx.font = '30px Raleway';
          this.ctx.textAlign = 'center';
          this.ctx.fillText(item.icon, item.x, item.y);
        });
      }

      update(deltaTime) {
        this.spawnTimer += deltaTime;
        const spawnInterval = 2000 - Math.min(this.score * 5, 1500);
        if (this.spawnTimer > spawnInterval) {
          this.spawnItem();
          this.spawnTimer = 0;
        }
       먝
        this.timer -= deltaTime / 1000;

        this.items.forEach(item => {
          if (!this.isDragging || item !== this.draggedItem) {
            item.y += item.speed * deltaTime / 16.67;
          }
        });

        this.items = this.items.filter(item => {
          if (item.y > this.canvas.height + 20) {
            this.lives -= 1;
            this.incorrectSound.triggerAttackRelease('C3', '8n');
            this.canvas.classList.add('flash-red');
            setTimeout(() => this.canvas.classList.remove('flash-red'), 500);
            return false;
          }
          return true;
        });

        this.scoreEl.textContent = `Puntos: ${this.score}`;
        this.livesEl.textContent = `Vidas: ${'仇벒잺'.repeat(Math.max(0, this.lives))}`;
        this.timerEl.textContent = `Tiempo: ${Math.max(0, Math.floor(this.timer))}`;
       먝
        if (this.lives <= 0 || this.timer <= 0) this.gameOver = true;
      }

      gameLoop(currentTime) {
        if (this.gameOver) {
          this.messageTitleEl.textContent = "춰Juego Terminado!";
          this.messageTextEl.textContent = `춰Has conseguido ${this.score} puntos!`;
          this.messageBoxEl.style.display = 'flex';
          return;
        }
       먝
        if (this.paused) {
          return;
        }
       먝
        const deltaTime = currentTime - this.lastTime;
        this.lastTime = currentTime;
        this.update(deltaTime);
        this.draw();
        this.frameId = requestAnimationFrame(this.gameLoop.bind(this));
      }
    }
   먝
    window.onload = function() {
      const canvas = document.getElementById('gameCanvas');
      const gameScoreEl = document.getElementById('gameScore');
      const gameLivesEl = document.getElementById('gameLives');
      const gameTimerEl = document.getElementById('gameTimer');
      const messageBoxEl = document.getElementById('messageBox');
      const messageTitleEl = document.getElementById('messageTitle');
      const messageTextEl = document.getElementById('messageText');
      const restartButtonEl = document.getElementById('restartButton');
      const toggleButtonEl = document.getElementById('toggleButton');
      const toggleIconEl = document.getElementById('toggleIcon');
      const toggleTextEl = document.getElementById('toggleText');
      const restartGameButtonEl = document.getElementById('restartGameButton');
      const returnButtonEl = document.getElementById('returnButton');
      const backGameButtonEl = document.getElementById('backGameButton');

      const game = new RecyclingGame(canvas, gameScoreEl, gameLivesEl, gameTimerEl, messageBoxEl, messageTitleEl, messageTextEl, restartButtonEl, toggleButtonEl, toggleIconEl, toggleTextEl, returnButtonEl, backGameButtonEl);
      window.addEventListener('resize', game.resizeCanvas);
      game.start();

      restartGameButtonEl.addEventListener('click', () => game.restart());
    };
  </script>

</body>

</html>
