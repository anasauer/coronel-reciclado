<!DOCTYPE html>

<html lang="es">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Juego de Reciclado</title>

    <script src="https://cdn.tailwindcss.com"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">

    <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@400;700;900&display=swap" rel="stylesheet">

    <style>

        body {

            font-family: 'Raleway', sans-serif;

            background-image: url('img/ruinas.png');

            background-size: cover;

            background-position: center;

            background-attachment: fixed;

            color: #f9fafb;

            display: flex;

            align-items: center;

            justify-content: center;

            min-height: 100vh;

            text-align: center;

            padding: 20px;

        }

        .game-wrapper {

            background-color: rgba(17, 24, 39, 0.7);

            padding: 2rem;

            border-radius: 1.5rem;

            display: flex;

            flex-direction: column;

            align-items: center;

            width: 100%;

            max-width: 600px;

        }

        #gameCanvas {

            border-radius: 1rem;

            background-color: rgba(20, 25, 20, 0.8);

            border: 2px solid #4b5563;

            cursor: pointer;

            touch-action: none;

            width: 100%;

            height: auto;

            max-width: 450px;

            transition: all 0.3s ease;

        }

        .game-info {

            margin: 1rem 0;

            display: flex;

            flex-wrap: wrap;

            justify-content: center;

            align-items: center;

            gap: 1rem 2rem;

            font-weight: bold;

        }

        .flash-red {

            animation: incorrectPlacement 0.5s forwards;

        }

        @keyframes incorrectPlacement {

            0% { background-color: #ef4444; }

            100% { background-color: rgba(20, 25, 20, 0.8); }

        }

        .message-box {

            position: absolute;

            top: 50%;

            left: 50%;

            transform: translate(-50%, -50%);

            background-color: rgba(0, 0, 0, 0.8);

            border-radius: 1rem;

            padding: 2rem;

            border: 2px solid #3b82f6;

            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);

            display: none;

            z-index: 100;

        }

        .btn {

            background-color: #4b5563;

            color: white;

            padding: 0.75rem 1.5rem;

            border-radius: 9999px;

            font-weight: 600;

            transition-property: background-color, transform;

            transition-duration: 300ms;

            transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);

        }

        .btn:hover {

            background-color: #6b7280;

            transform: scale(1.05);

        }

    </style>

</head>

<body>

    <div class="game-wrapper">

        <h1 class="text-3xl font-bold mb-4">♻️ Juego de Reciclado</h1>

        <p class="mb-4">Arrastra y suelta los objetos en el contenedor correcto.</p>

        <div class="game-info">

            <div id="gameScore">Puntos: 0</div>

            <div id="gameLives">Vidas: ❤️❤️❤️❤️❤️</div>

            <div id="gameTimer">Tiempo: 60</div>

            <button id="backGameButton" class="btn bg-gray-600 hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-slate-900">

                <i class="fas fa-arrow-left"></i>

                <span>Regresar</span>

            </button>

            <button id="restartGameButton" class="btn bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 focus:ring-offset-slate-900">

                <i class="fas fa-arrows-rotate"></i>

                <span>Reiniciar</span>

            </button>

            <button id="toggleButton" class="btn bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 focus:ring-offset-slate-900">

                <i id="toggleIcon" class="fas fa-pause"></i>

                <span id="toggleText">Pausar</span>

            </button>

        </div>

        <div class="relative w-full max-w-lg aspect-square">

            <canvas id="gameCanvas"></canvas>

            <div id="messageBox" class="message-box flex flex-col items-center justify-center text-center">

                <h2 id="messageTitle" class="text-xl font-bold text-gray-100 mb-2"></h2>

                <p id="messageText" class="text-gray-300 mb-4"></p>

                <button id="restartButton" class="btn btn-green">

                    Jugar de Nuevo

                </button>

                <button id="returnButton" class="btn bg-gray-600 hover:bg-gray-700 mt-4">

                    Regresar a la página principal

                </button>

            </div>

        </div>

    </div>



   <script>
        class RecyclingGame {
            constructor(canvas, scoreEl, livesEl, timerEl, messageBoxEl, messageTitleEl, messageTextEl, restartButtonEl, toggleButtonEl, toggleIconEl, toggleTextEl, returnButtonEl, backGameButtonEl) {
                this.canvas = canvas;
                this.ctx = this.canvas.getContext('2d');
                this.scoreEl = scoreEl;
                this.livesEl = livesEl;
                this.timerEl = timerEl;
                this.messageBoxEl = messageBoxEl;
                this.messageTitleEl = messageTitleEl;
                this.messageTextEl = messageTextEl;
                this.restartButtonEl = restartButtonEl;
                this.toggleButtonEl = toggleButtonEl;
                this.toggleIconEl = toggleIconEl;
                this.toggleTextEl = toggleTextEl;
                this.returnButtonEl = returnButtonEl; 
                this.backGameButtonEl = backGameButtonEl;

                this.items = [];
                this.bins = [];
                this.score = parseInt(localStorage.getItem('currentScore')) || 0;
                this.lives = 5;
                this.timer = 60;
                this.gameOver = false;
                this.isDragging = false;
                this.draggedItem = null;
                this.frameId = null;
                this.spawnTimer = 0;
                this.lastTime = 0;
                this.paused = false;

                this.itemTypes = [
                    { type: 'glass', icon: '🍾', binSrc: 'img/vidrio.png', name: 'Vidrio' },
                    { type: 'paper', icon: '📄', binSrc: 'img/papel.png', name: 'Papel' },
                    { type: 'plastic', icon: '🧴', binSrc: 'img/plastico.png', name: 'Plástico' },
                    { type: 'metal', icon: '🥫', binSrc: 'img/metal.png', name: 'Metal' },
                    { type: 'organic', icon: '🍎', binSrc: 'img/organico.png', name: 'Orgánico' }
                ];

                this.correctSound = new Tone.Synth({
                    oscillator: { type: 'sine' },
                    envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.4 }
                }).toDestination();
                this.incorrectSound = new Tone.Synth({
                    oscillator: { type: 'square' },
                    envelope: { attack: 0.01, decay: 0.1, sustain: 0.01, release: 0.2 }
                }).toDestination();
                
                this.resizeCanvas = this.resizeCanvas.bind(this);
                this.gameLoop = this.gameLoop.bind(this);
                
                // Bind unified event handlers
                this.handleStart = this.handleStart.bind(this);
                this.handleMove = this.handleMove.bind(this);
                this.handleEnd = this.handleEnd.bind(this);

                this.restartButtonEl.addEventListener('click', () => this.restart());
                this.toggleButtonEl.addEventListener('click', () => this.togglePause());
                this.returnButtonEl.addEventListener('click', () => this.returnToHome());
                this.backGameButtonEl.addEventListener('click', () => this.returnToHome());
                
                this.addEventListeners();
            }

            addEventListeners() {
                // Remove old listeners to prevent duplication
                this.canvas.removeEventListener('mousedown', this.handleStart);
                this.canvas.removeEventListener('mousemove', this.handleMove);
                this.canvas.removeEventListener('mouseup', this.handleEnd);
                this.canvas.removeEventListener('touchstart', this.handleStart);
                this.canvas.removeEventListener('touchmove', this.handleMove);
                this.canvas.removeEventListener('touchend', this.handleEnd);

                // Add unified listeners
                this.canvas.addEventListener('mousedown', this.handleStart);
                this.canvas.addEventListener('mousemove', this.handleMove);
                this.canvas.addEventListener('mouseup', this.handleEnd);
                this.canvas.addEventListener('touchstart', this.handleStart);
                this.canvas.addEventListener('touchmove', this.handleMove);
                this.canvas.addEventListener('touchend', this.handleEnd);
            }

            getPointerPosition(e) {
                const rect = this.canvas.getBoundingClientRect();
                let clientX, clientY;

                // Handle both mouse and touch events
                if (e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else if (e.changedTouches && e.changedTouches.length > 0) {
                    clientX = e.changedTouches[0].clientX;
                    clientY = e.changedTouches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                // Corregimos la posición relativa al tamaño real del canvas
                // Asegura que la posición del mouse/dedo se mapee correctamente
                // al sistema de coordenadas interno del canvas.
                return {
                    x: (clientX - rect.left) * (this.canvas.width / rect.width),
                    y: (clientY - rect.top) * (this.canvas.height / rect.height)
                };
            }

            handleStart(e) {
                e.preventDefault();
                if (this.gameOver || this.paused) return;
                const pos = this.getPointerPosition(e);
                for (let i = this.items.length - 1; i >= 0; i--) {
                    const item = this.items[i];
                    // Se ha aumentado el área de detección para facilitar el toque en móviles
                    if (Math.abs(pos.x - item.x) < 30 && Math.abs(pos.y - item.y) < 30) {
                        this.isDragging = true;
                        this.draggedItem = item;
                        // Mueve el item arrastrado al final del array para que se dibuje por encima de todo
                        this.items = this.items.filter(i => i !== item);
                        this.items.push(item);
                        return;
                    }
                }
            }

            handleMove(e) {
                e.preventDefault();
                if (!this.isDragging || !this.draggedItem) return;
                const pos = this.getPointerPosition(e);
                this.draggedItem.x = pos.x;
                this.draggedItem.y = pos.y;
            }

            handleEnd(e) {
                // e.preventDefault() NO se usa en touchend/mouseup a menos que quieras prevenir un click fantasma
                if (!this.draggedItem) return;
                
                // Get the final position for the drop
                const pos = this.getPointerPosition(e);
                this.draggedItem.x = pos.x;
                this.draggedItem.y = pos.y;
                
                let placedCorrectly = false;
                for (const bin of this.bins) {
                    // Aumenta el área de detección de la colisión para móvil
                    const xCollision = this.draggedItem.x > bin.x && this.draggedItem.x < bin.x + bin.width;
                    const yCollision = this.draggedItem.y > bin.y && this.draggedItem.y < bin.y + bin.height;

                    if (xCollision && yCollision) {
                        if (this.draggedItem.type === bin.type) {
                            this.score += 10;
                            placedCorrectly = true;
                            this.correctSound.triggerAttackRelease('C5', '8n');
                        } else {
                            this.lives -= 1;
                            this.canvas.classList.add('flash-red');
                            setTimeout(() => this.canvas.classList.remove('flash-red'), 500);
                            this.incorrectSound.triggerAttackRelease('C3', '8n');
                        }
                        this.items = this.items.filter(item => item !== this.draggedItem);
                        break;
                    }
                }
                this.isDragging = false;
                this.draggedItem = null;
            }

            // [resto de las funciones sin cambios, como resizeCanvas, start, etc.]
            // Se han omitido aquí por brevedad, pero en tu archivo final, las mantienes.
            resizeCanvas() {
                const container = this.canvas.parentElement;
                const size = Math.min(container.clientWidth, 450);
                this.canvas.width = size;
                this.canvas.height = size;
                this.initBins();
                this.draw();
            }

            start() {
                this.score = parseInt(localStorage.getItem('currentScore')) || 0;
                this.lives = 5;
                this.timer = 60;
                this.gameOver = false;
                this.items = [];
                this.spawnTimer = 0;
                this.lastTime = performance.now();
                this.paused = false;
                
                this.toggleIconEl.classList.remove('fa-play');
                this.toggleIconEl.classList.add('fa-pause');
                this.toggleTextEl.textContent = 'Pausar';
                
                this.scoreEl.textContent = `Puntos: ${this.score}`;
                this.livesEl.textContent = `Vidas: ${'❤️'.repeat(this.lives)}`;
                this.timerEl.textContent = `Tiempo: ${this.timer}`;
                this.messageBoxEl.style.display = 'none';
                
                this.resizeCanvas();
                
                if (this.frameId) {
                    cancelAnimationFrame(this.frameId);
                }
                this.gameLoop(this.lastTime);
            }

            restart() {
                // Reinicia el puntaje tanto en memoria como en localStorage
                localStorage.setItem('currentScore', '0');
                this.start();
            }

            // Guarda el puntaje en localStorage antes de regresar
            returnToHome() {
                if (this.frameId) {
                    cancelAnimationFrame(this.frameId);
                }
                // Guarda el puntaje actual en localStorage
                localStorage.setItem('currentScore', this.score.toString());
                // Por razones de seguridad, es mejor no redirigir a URLs externas
                // window.location.href = "home.html";
                // En su lugar, podemos mostrar un mensaje
                this.messageTitleEl.textContent = "Volverás pronto";
                this.messageTextEl.textContent = `Puntuación guardada: ${this.score}.`;
                this.messageBoxEl.style.display = 'flex';
                this.returnButtonEl.style.display = 'none';
            }

            togglePause() {
                this.paused = !this.paused;
                if (this.paused) {
                    this.toggleIconEl.classList.remove('fa-pause');
                    this.toggleIconEl.classList.add('fa-play');
                    this.toggleTextEl.textContent = 'Reanudar';
                } else {
                    this.toggleIconEl.classList.remove('fa-play');
                    this.toggleIconEl.classList.add('fa-pause');
                    this.toggleTextEl.textContent = 'Pausar';
                    this.lastTime = performance.now();
                    this.gameLoop(this.lastTime);
                }
            }

            initBins() {
                this.bins = [];
                const binWidth = this.canvas.width / this.itemTypes.length - 15;
                const binHeight = this.canvas.height / 5;
                const binY = this.canvas.height - binHeight - 20;

                this.itemTypes.forEach((type, index) => {
                    const binImage = new Image();
                    binImage.src = type.binSrc;
                    binImage.onerror = () => { console.error(`Error loading image: ${type.binSrc}`); };
                    this.bins.push({
                        x: (index + 0.5) * (binWidth + 15) - binWidth / 2,
                        y: binY,
                        width: binWidth,
                        height: binHeight,
                        type: type.type,
                        name: type.name,
                        image: binImage
                    });
                });
            }

            spawnItem() {
                const randomType = this.itemTypes[Math.floor(Math.random() * this.itemTypes.length)];
                const speed = 0.5 + this.score / 200;
                this.items.push({
                    x: Math.random() * (this.canvas.width - 60) + 30,
                    y: -30,
                    icon: randomType.icon,
                    type: randomType.type,
                    speed: speed,
                    isDragging: false
                });
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.bins.forEach(bin => {
                    this.ctx.drawImage(bin.image, bin.x, bin.y, bin.width, bin.height);
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = 'bold 16px Raleway';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(bin.name, bin.x + bin.width / 2, bin.y + bin.height + 20);
                });

                this.items.forEach(item => {
                    this.ctx.font = '30px Raleway';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(item.icon, item.x, item.y);
                });
            }

            update(deltaTime) {
                this.spawnTimer += deltaTime;
                const spawnInterval = 2000 - Math.min(this.score * 5, 1500);
                if (this.spawnTimer > spawnInterval) {
                    this.spawnItem();
                    this.spawnTimer = 0;
                }
                
                this.timer -= deltaTime / 1000;

                this.items.forEach(item => {
                    if (!this.isDragging || item !== this.draggedItem) {
                        item.y += item.speed * deltaTime / 16.67;
                    }
                });

                this.items = this.items.filter(item => {
                    if (item.y > this.canvas.height + 20) {
                        this.lives -= 1;
                        this.incorrectSound.triggerAttackRelease('C3', '8n');
                        this.canvas.classList.add('flash-red');
                        setTimeout(() => this.canvas.classList.remove('flash-red'), 500);
                        return false;
                    }
                    return true;
                });

                this.scoreEl.textContent = `Puntos: ${this.score}`;
                this.livesEl.textContent = `Vidas: ${'❤️'.repeat(Math.max(0, this.lives))}`;
                this.timerEl.textContent = `Tiempo: ${Math.max(0, Math.floor(this.timer))}`;
                
                if (this.lives <= 0 || this.timer <= 0) this.gameOver = true;
            }

            gameLoop(currentTime) {
                if (this.gameOver) {
                    this.messageTitleEl.textContent = "¡Juego Terminado!";
                    this.messageTextEl.textContent = `¡Has conseguido ${this.score} puntos!`;
                    this.messageBoxEl.style.display = 'flex';
                    return;
                }
                
                if (this.paused) {
                    return;
                }
                
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                this.update(deltaTime);
                this.draw();
                this.frameId = requestAnimationFrame(this.gameLoop.bind(this));
            }
        }
        
        window.onload = function() {
            const canvas = document.getElementById('gameCanvas');
            const gameScoreEl = document.getElementById('gameScore');
            const gameLivesEl = document.getElementById('gameLives');
            const gameTimerEl = document.getElementById('gameTimer');
            const messageBoxEl = document.getElementById('messageBox');
            const messageTitleEl = document.getElementById('messageTitle');
            const messageTextEl = document.getElementById('messageText');
            const restartButtonEl = document.getElementById('restartButton');
            const toggleButtonEl = document.getElementById('toggleButton');
            const toggleIconEl = document.getElementById('toggleIcon');
            const toggleTextEl = document.getElementById('toggleText');
            const restartGameButtonEl = document.getElementById('restartGameButton');
            const returnButtonEl = document.getElementById('returnButton');
            const backGameButtonEl = document.getElementById('backGameButton');

            const game = new RecyclingGame(canvas, gameScoreEl, gameLivesEl, gameTimerEl, messageBoxEl, messageTitleEl, messageTextEl, restartButtonEl, toggleButtonEl, toggleIconEl, toggleTextEl, returnButtonEl, backGameButtonEl);
            window.addEventListener('resize', game.resizeCanvas);
            game.start();

            restartGameButtonEl.addEventListener('click', () => game.restart());
        };
    </script>

</body>

</html>
